From 5ae9ddb9a4086c63a50bd3c4c96a06fad04f3be9 Mon Sep 17 00:00:00 2001
From: Ross Lagerwall <ross.lagerwall@citrix.com>
Date: Wed, 13 May 2015 12:44:29 +0100
Subject: [PATCH] x86/HVM: Avoid cache flush operations during hvm_load

An MTRR record is processed for each vCPU during hvm_load. Each MTRR
record sets several mtrrs, each of which flushes the cache on all pCPUs.
This can take some time and trip the watchdog for HVM guests with many
CPUs.

To fix this, introduce a flag which prevents flushing the cache when
doing MTRR operations and instead do a flush at the end of hvm_load.

This reduces the time to restore an HVM guest with 32 vCPUs by about 5
seconds.

Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
diff --git a/xen/arch/x86/hvm/mtrr.c b/xen/arch/x86/hvm/mtrr.c
index 4620ed427cba..7de24f494ca1 100644
--- a/xen/arch/x86/hvm/mtrr.c
+++ b/xen/arch/x86/hvm/mtrr.c
@@ -44,6 +44,8 @@ static const uint8_t mm_type_tbl[MTRR_NUM_TYPES][X86_NUM_MT] = {
 #undef RS
 };
 
+DEFINE_PER_CPU(bool, memory_type_changed_ignore);
+
 /*
  * Reverse lookup table, to find a pat type according to MTRR and effective
  * memory type. This table is dynamically generated.
@@ -778,6 +780,9 @@ HVM_REGISTER_SAVE_RESTORE(MTRR, hvm_save_mtrr_msr, NULL, hvm_load_mtrr_msr, 1,
 
 void memory_type_changed(struct domain *d)
 {
+    if ( this_cpu(memory_type_changed_ignore) )
+        return;
+
     if ( (is_iommu_enabled(d) || cache_flush_permitted(d)) &&
          d->vcpu && d->vcpu[0] )
     {
diff --git a/xen/arch/x86/hvm/save.c b/xen/arch/x86/hvm/save.c
index 8ab64057064e..859fa281bf64 100644
--- a/xen/arch/x86/hvm/save.c
+++ b/xen/arch/x86/hvm/save.c
@@ -319,6 +319,8 @@ int hvm_load(struct domain *d, bool real, hvm_domain_context_t *h)
     else if ( rc )
         return rc;
 
+    this_cpu(memory_type_changed_ignore) = true;
+
     for ( ; ; )
     {
         const char *name;
@@ -331,7 +333,8 @@ int hvm_load(struct domain *d, bool real, hvm_domain_context_t *h)
                    "HVM%d restore: save did not end with a null entry\n",
                    d->domain_id);
             ASSERT(!real);
-            return -ENODATA;
+            rc = -ENODATA;
+            goto out;
         }
 
         /* Read the typecode of the next entry  and check for the end-marker */
@@ -341,7 +344,7 @@ int hvm_load(struct domain *d, bool real, hvm_domain_context_t *h)
             /* Reset cursor for hvm_load(, true, ). */
             if ( !real )
                 h->cur = 0;
-            return 0;
+            goto out;
         }
 
         /* Find the handler for this entry */
@@ -352,7 +355,8 @@ int hvm_load(struct domain *d, bool real, hvm_domain_context_t *h)
             printk(XENLOG_G_ERR "HVM%d restore: unknown entry typecode %u\n",
                    d->domain_id, desc->typecode);
             ASSERT(!real);
-            return -EINVAL;
+            rc = -EINVAL;
+            goto out;
         }
 
         if ( real )
@@ -370,7 +374,10 @@ int hvm_load(struct domain *d, bool real, hvm_domain_context_t *h)
             if ( !check )
             {
                 if ( desc->length > h->size - h->cur - sizeof(*desc) )
-                    return -ENODATA;
+                {
+                    rc = -ENODATA;
+                    goto out;
+                }
                 h->cur += sizeof(*desc) + desc->length;
                 rc = 0;
             }
@@ -382,13 +389,18 @@ int hvm_load(struct domain *d, bool real, hvm_domain_context_t *h)
         {
             printk(XENLOG_G_ERR "HVM restore %pd: failed to %s %s:%u rc %d\n",
                    d, real ? "load" : "check", name, desc->instance, rc);
-            return rc;
+            goto out;
         }
 
         process_pending_softirqs();
     }
 
-    /* Not reached */
+    ASSERT_UNREACHABLE();
+
+ out:
+    this_cpu(memory_type_changed_ignore) = false;
+    memory_type_changed(d);
+    return rc;
 }
 
 int _hvm_init_entry(struct hvm_domain_context *h, uint16_t tc, uint16_t inst,
diff --git a/xen/arch/x86/include/asm/mtrr.h b/xen/arch/x86/include/asm/mtrr.h
index 36dac0a775a3..b57209708008 100644
--- a/xen/arch/x86/include/asm/mtrr.h
+++ b/xen/arch/x86/include/asm/mtrr.h
@@ -48,6 +48,15 @@ struct mtrr_state {
 };
 extern struct mtrr_state mtrr_state;
 
+/*
+ * The purpose of the memory_type_changed_ignore cpu flag is to
+ * avoid unecessary cache flushes when doing multiple memory type
+ * operations that may flush the cache. Code can set this flag, do
+ * several memory type operations, clear the flag and then call
+ * memory_type_changed() to flush the cache at the end.
+ */
+DECLARE_PER_CPU(bool, memory_type_changed_ignore);
+
 extern void cf_check mtrr_save_fixed_ranges(void *info);
 extern void mtrr_save_state(void);
 extern int mtrr_add(unsigned long base, unsigned long size,
