xen/pci: Cache the state of the MSI-X enabled bit

When MSI-X PIRQs are bound to vCPUs, Xen will check the state of the
MSI-X enabled bit several times each time the vCPU is migrated. On a
busy system, this happens frequently. The PCI config cycle load causes
some buggy PCI devices to crash (e.g. Cisco VIC UCSX-ML-V5D200GV2).

Fix this by tracking the state of the MSI-X decoded bit and using the
cached state instead of generating a config read for the common cases.

Signed-off-by: Ross Lagerwall <ross.lagerwall@citrix.com>
diff --git a/xen/arch/x86/include/asm/msi.h b/xen/arch/x86/include/asm/msi.h
index 748bc3cd6d8b..33fa8a4a8eeb 100644
--- a/xen/arch/x86/include/asm/msi.h
+++ b/xen/arch/x86/include/asm/msi.h
@@ -229,7 +229,7 @@ struct arch_msix {
 #define ADJ_IDX_LAST  1
     unsigned int adj_access_idx[2];
     spinlock_t table_lock;
-    bool host_maskall, guest_maskall;
+    bool host_maskall, guest_maskall, enabled;
     domid_t warned_domid;
     union {
         uint8_t all;
diff --git a/xen/arch/x86/msi.c b/xen/arch/x86/msi.c
index 78dbfdfc3c2d..9bc3fa1bd714 100644
--- a/xen/arch/x86/msi.c
+++ b/xen/arch/x86/msi.c
@@ -142,9 +142,7 @@ static bool memory_decoded(const struct pci_dev *dev)
 
 static bool msix_memory_decoded(const struct pci_dev *dev, unsigned int pos)
 {
-    uint16_t control = pci_conf_read16(dev->sbdf, msix_control_reg(pos));
-
-    if ( !(control & PCI_MSIX_FLAGS_ENABLE) )
+    if ( !dev->msix->enabled )
         return false;
 
     return memory_decoded(dev);
@@ -304,6 +302,7 @@ static void msix_set_enable(struct pci_dev *dev, int enable)
         if ( enable )
             control |= PCI_MSIX_FLAGS_ENABLE;
         pci_conf_write16(dev->sbdf, msix_control_reg(pos), control);
+        dev->msix->enabled = !!enable;
     }
 }
 
@@ -319,7 +318,7 @@ static bool msi_set_mask_bit(struct irq_desc *desc, bool host, bool guest)
     struct msi_desc *entry = desc->msi_desc;
     struct pci_dev *pdev;
     uint16_t control;
-    bool flag = host || guest, maskall;
+    bool flag = host || guest, maskall, was_enabled;
 
     ASSERT(spin_is_locked(&desc->lock));
     BUG_ON(!entry || !entry->dev);
@@ -339,10 +338,12 @@ static bool msi_set_mask_bit(struct irq_desc *desc, bool host, bool guest)
         break;
     case PCI_CAP_ID_MSIX:
         maskall = pdev->msix->host_maskall;
-        control = pci_conf_read16(pdev->sbdf,
-                                  msix_control_reg(entry->msi_attrib.pos));
-        if ( unlikely(!(control & PCI_MSIX_FLAGS_ENABLE)) )
+        was_enabled = pdev->msix->enabled;
+        if ( unlikely(!was_enabled) )
         {
+            control = pci_conf_read16(pdev->sbdf,
+                                      msix_control_reg(entry->msi_attrib.pos));
+            pdev->msix->enabled = true;
             pdev->msix->host_maskall = 1;
             pci_conf_write16(pdev->sbdf,
                              msix_control_reg(entry->msi_attrib.pos),
@@ -354,7 +355,7 @@ static bool msi_set_mask_bit(struct irq_desc *desc, bool host, bool guest)
             writel(flag, entry->mask_base + PCI_MSIX_ENTRY_VECTOR_CTRL_OFFSET);
             readl(entry->mask_base + PCI_MSIX_ENTRY_VECTOR_CTRL_OFFSET);
 
-            if ( likely(control & PCI_MSIX_FLAGS_ENABLE) )
+            if ( likely(was_enabled) )
                 break;
 
             entry->msi_attrib.host_masked = host;
@@ -362,15 +363,21 @@ static bool msi_set_mask_bit(struct irq_desc *desc, bool host, bool guest)
 
             flag = true;
         }
-        else if ( flag && !(control & PCI_MSIX_FLAGS_MASKALL) )
+        else
         {
-            domid_t domid = pdev->domain->domain_id;
+            if ( was_enabled )
+                control = pci_conf_read16(pdev->sbdf,
+                                          msix_control_reg(entry->msi_attrib.pos));
+            if ( flag && !(control & PCI_MSIX_FLAGS_MASKALL) )
+            {
+                domid_t domid = pdev->domain->domain_id;
 
-            maskall = true;
-            if ( MSIX_CHECK_WARN(pdev->msix, domid, maskall) )
-                printk(XENLOG_G_WARNING
-                       "cannot mask IRQ %d: masking MSI-X on Dom%d's %pp\n",
-                       desc->irq, domid, &pdev->sbdf);
+                maskall = true;
+                if ( MSIX_CHECK_WARN(pdev->msix, domid, maskall) )
+                    printk(XENLOG_G_WARNING
+                           "cannot mask IRQ %d: masking MSI-X on Dom%d's %pp\n",
+                           desc->irq, domid, &pdev->sbdf);
+            }
         }
         pdev->msix->host_maskall = maskall;
         if ( maskall || pdev->msix->guest_maskall )
@@ -510,9 +517,12 @@ int setup_msi_irq(struct irq_desc *desc, struct msi_desc *msidesc)
     {
         control = pci_conf_read16(pdev->sbdf, cpos);
         if ( !(control & PCI_MSIX_FLAGS_ENABLE) )
+        {
             pci_conf_write16(pdev->sbdf, cpos,
                              control | (PCI_MSIX_FLAGS_ENABLE |
                                         PCI_MSIX_FLAGS_MASKALL));
+            pdev->msix->enabled = true;
+        }
     }
 
     rc = __setup_msi_irq(desc, msidesc,
@@ -520,7 +530,10 @@ int setup_msi_irq(struct irq_desc *desc, struct msi_desc *msidesc)
                                                    : &pci_msi_nonmaskable);
 
     if ( !(control & PCI_MSIX_FLAGS_ENABLE) )
+    {
         pci_conf_write16(pdev->sbdf, cpos, control);
+        pdev->msix->enabled = false;
+    }
 
     return rc;
 }
@@ -781,12 +794,14 @@ static int msix_capability_init(struct pci_dev *dev,
      * fully set up.
      */
     msix->host_maskall = 1;
+    msix->enabled = true;
     pci_conf_write16(dev->sbdf, msix_control_reg(pos),
                      control | (PCI_MSIX_FLAGS_ENABLE |
                                 PCI_MSIX_FLAGS_MASKALL));
 
     if ( unlikely(!memory_decoded(dev)) )
     {
+        msix->enabled = false;
         pci_conf_write16(dev->sbdf, msix_control_reg(pos),
                          control & ~PCI_MSIX_FLAGS_ENABLE);
         return -ENXIO;
@@ -797,6 +812,7 @@ static int msix_capability_init(struct pci_dev *dev,
         entry = alloc_msi_entry(1);
         if ( !entry )
         {
+            msix->enabled = false;
             pci_conf_write16(dev->sbdf, msix_control_reg(pos),
                              control & ~PCI_MSIX_FLAGS_ENABLE);
             return -ENOMEM;
@@ -842,6 +858,7 @@ static int msix_capability_init(struct pci_dev *dev,
         {
             if ( !msi || !msi->table_base )
             {
+                msix->enabled = false;
                 pci_conf_write16(dev->sbdf, msix_control_reg(pos),
                                  control & ~PCI_MSIX_FLAGS_ENABLE);
                 xfree(entry);
@@ -896,6 +913,7 @@ static int msix_capability_init(struct pci_dev *dev,
                 msix->table.first = 0;
                 msix->pba.first = 0;
 
+                msix->enabled = false;
                 control &= ~PCI_MSIX_FLAGS_ENABLE;
             }
 
@@ -999,6 +1017,7 @@ static int msix_capability_init(struct pci_dev *dev,
          * brain model where Dom0 actually enables MSI (and disables INTx).
          */
         pci_intx(dev, false);
+        msix->enabled = true;
         control |= PCI_MSIX_FLAGS_ENABLE;
         control &= ~PCI_MSIX_FLAGS_MASKALL;
         maskall = 0;
@@ -1149,6 +1168,7 @@ static void __pci_disable_msix(struct msi_desc *entry)
     if ( unlikely(!(control & PCI_MSIX_FLAGS_ENABLE)) )
     {
         dev->msix->host_maskall = 1;
+        dev->msix->enabled = 1;
         pci_conf_write16(dev->sbdf, msix_control_reg(pos),
                          control | (PCI_MSIX_FLAGS_ENABLE |
                                     PCI_MSIX_FLAGS_MASKALL));
@@ -1264,6 +1284,9 @@ int pci_reset_msix_state(struct pci_dev *pdev)
 
     pdev->msix->host_maskall = false;
     pdev->msix->guest_maskall = false;
+    pdev->msix->enabled =
+        !!(pci_conf_read16(pdev->sbdf, msix_control_reg(pos)) &
+               PCI_MSIX_FLAGS_ENABLE);
 
     return 0;
 }
@@ -1289,6 +1312,7 @@ int pci_msi_conf_write_intercept(struct pci_dev *pdev, unsigned int reg,
             pdev->msix->guest_maskall = !!(*data & PCI_MSIX_FLAGS_MASKALL);
             if ( pdev->msix->host_maskall )
                 *data |= PCI_MSIX_FLAGS_MASKALL;
+            pdev->msix->enabled = !!(*data & PCI_MSIX_FLAGS_ENABLE);
 
             return 1;
         }
@@ -1367,8 +1391,11 @@ int pci_restore_msi_state(struct pci_dev *pdev)
                     &pdev->sbdf, i);
             spin_unlock_irqrestore(&desc->lock, flags);
             if ( type == PCI_CAP_ID_MSIX )
+            {
                 pci_conf_write16(pdev->sbdf, msix_control_reg(pos),
                                  control & ~PCI_MSIX_FLAGS_ENABLE);
+                pdev->msix->enabled = false;
+            }
             return -EINVAL;
         }
 
@@ -1385,11 +1412,13 @@ int pci_restore_msi_state(struct pci_dev *pdev)
             pci_conf_write16(pdev->sbdf, msix_control_reg(pos),
                              control | (PCI_MSIX_FLAGS_ENABLE |
                                         PCI_MSIX_FLAGS_MASKALL));
+            pdev->msix->enabled = true;
             if ( unlikely(!memory_decoded(pdev)) )
             {
                 spin_unlock_irqrestore(&desc->lock, flags);
                 pci_conf_write16(pdev->sbdf, msix_control_reg(pos),
                                  control & ~PCI_MSIX_FLAGS_ENABLE);
+                pdev->msix->enabled = false;
                 return -ENXIO;
             }
         }
@@ -1430,8 +1459,11 @@ int pci_restore_msi_state(struct pci_dev *pdev)
     }
 
     if ( type == PCI_CAP_ID_MSIX )
+    {
         pci_conf_write16(pdev->sbdf, msix_control_reg(pos),
                          control | PCI_MSIX_FLAGS_ENABLE);
+        pdev->msix->enabled = true;
+    }
 
     return 0;
 }
