From 8e6e0aa2a951a8a588bb62b71ca2038230758824 Mon Sep 17 00:00:00 2001
From: Andrii Sultanov <andriy.sultanov@vates.tech>
Date: Fri, 7 Nov 2025 09:28:21 +0000
Subject: [PATCH] populate_physmap debug logging

Signed-off-by: Andrii Sultanov <andriy.sultanov@vates.tech>
---
 xen/common/memory.c | 45 ++++++++++++++++++++++++++++++++++++---------
 1 file changed, 36 insertions(+), 9 deletions(-)

diff --git a/xen/common/memory.c b/xen/common/memory.c
index 1f0a9d7e5f..77bab8956a 100644
--- a/xen/common/memory.c
+++ b/xen/common/memory.c
@@ -164,13 +164,22 @@ static void populate_physmap(struct memop_args *a)
     bool need_tlbflush = false;
     uint32_t tlbflush_timestamp = 0;
 
+    printk( "populate_physmap {nr_extents = %d, extent_order = %d, memflags = %d, nr_done = %d, preempted = %d}\n",
+             a->nr_extents, a->extent_order, a->memflags, a->nr_done, a->preempted);
+
     if ( !guest_handle_subrange_okay(a->extent_list, a->nr_done,
                                      a->nr_extents-1) )
+    {
+        printk("guest_handle_subrange is not okay\n");
         return;
+    }
 
     if ( a->extent_order > (a->memflags & MEMF_populate_on_demand ? MAX_ORDER :
                             max_order(curr_d)) )
+    {
+        printk("extent order too big\n");
         return;
+    }
 
     if ( unlikely(!d->creation_finished) )
     {
@@ -196,15 +205,20 @@ static void populate_physmap(struct memop_args *a)
     for ( i = a->nr_done; i < a->nr_extents; i++ )
     {
         mfn_t mfn;
+        printk("populate_physmap: i = %d\n", i);
 
         if ( i != a->nr_done && hypercall_preempt_check() )
         {
             a->preempted = 1;
+            printk("populate_physmap: preempted\n");
             goto out;
         }
 
         if ( unlikely(__copy_from_guest_offset(&gpfn, a->extent_list, i, 1)) )
+        {
+            printk("populate_physmap: copy_from_guest_offset\n");
             goto out;
+        }
 
         if ( a->memflags & MEMF_populate_on_demand )
         {
@@ -228,7 +242,7 @@ static void populate_physmap(struct memop_args *a)
                 {
                     if ( !mfn_valid(mfn) )
                     {
-                        gdprintk(XENLOG_INFO, "Invalid mfn %#"PRI_mfn"\n",
+                        printk("Invalid mfn %#"PRI_mfn"\n",
                                  mfn_x(mfn));
                         goto out;
                     }
@@ -236,8 +250,7 @@ static void populate_physmap(struct memop_args *a)
                     page = mfn_to_page(mfn);
                     if ( !get_page(page, d) )
                     {
-                        gdprintk(XENLOG_INFO,
-                                 "mfn %#"PRI_mfn" doesn't belong to d%d\n",
+                        printk("mfn %#"PRI_mfn" doesn't belong to d%d\n",
                                   mfn_x(mfn), d->domain_id);
                         goto out;
                     }
@@ -254,8 +267,7 @@ static void populate_physmap(struct memop_args *a)
                  */
                 if ( a->extent_order != 0 )
                 {
-                    gdprintk(XENLOG_WARNING,
-                             "Cannot allocate static order-%u pages for %pd\n",
+                    printk("Cannot allocate static order-%u pages for %pd\n",
                              a->extent_order, d);
                     goto out;
                 }
@@ -263,8 +275,7 @@ static void populate_physmap(struct memop_args *a)
                 mfn = acquire_reserved_page(d, a->memflags);
                 if ( mfn_eq(mfn, INVALID_MFN) )
                 {
-                    gdprintk(XENLOG_WARNING,
-                             "%pd: failed to retrieve a reserved page\n",
+                    printk( "%pd: failed to retrieve a reserved page\n",
                              d);
                     goto out;
                 }
@@ -275,8 +286,7 @@ static void populate_physmap(struct memop_args *a)
 
                 if ( unlikely(!page) )
                 {
-                    gdprintk(XENLOG_INFO,
-                             "Could not allocate order=%u extent: id=%d memflags=%#x (%u of %u)\n",
+                    printk( "Could not allocate order=%u extent: id=%d memflags=%#x (%u of %u)\n",
                              a->extent_order, d->domain_id, a->memflags,
                              i, a->nr_extents);
                     goto out;
@@ -293,16 +303,23 @@ static void populate_physmap(struct memop_args *a)
             }
 
             if ( guest_physmap_add_page(d, _gfn(gpfn), mfn, a->extent_order) )
+            {
+                printk("populate_physmap: guest_physmap_add_page\n");
                 goto out;
+            }
 
             if ( !paging_mode_translate(d) &&
                  /* Inform the domain of the new page's machine address. */
                  unlikely(__copy_mfn_to_guest_offset(a->extent_list, i, mfn)) )
+            {
+                printk("populate_physmap: paging_mode_translate && copy\n");
                 goto out;
+            }
         }
     }
 
 out:
+    printk("populate_physmap: out\n");
     if ( need_tlbflush )
         filtered_flush_tlb_mask(tlbflush_timestamp);
 
@@ -1406,19 +1423,29 @@ long do_memory_op(unsigned long cmd, XEN_GUEST_HANDLE_PARAM(void) arg)
     case XENMEM_increase_reservation:
     case XENMEM_decrease_reservation:
     case XENMEM_populate_physmap:
+
         if ( copy_from_guest(&reservation, arg, 1) )
             return start_extent;
 
         /* Is size too large for us to encode a continuation? */
         if ( reservation.nr_extents > (UINT_MAX >> MEMOP_EXTENT_SHIFT) )
+        {
+            printk("reservation.nr_extents > (uint_max>>shift)\n");
             return start_extent;
+        }
 
         if ( unlikely(start_extent >= reservation.nr_extents) )
+        {
+            printk("start_extent >= reservation.nr_extents\n");
             return start_extent;
+        }
 
         d = rcu_lock_domain_by_any_id(reservation.domid);
         if ( d == NULL )
+        {
+            printk("rcu_lock?\n");
             return start_extent;
+        }
         args.domain = d;
 
         if ( construct_memop_from_reservation(&reservation, &args) )
