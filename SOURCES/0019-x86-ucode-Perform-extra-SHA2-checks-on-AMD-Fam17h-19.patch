From 37cb107a6a93438663f326737875d07ef7c2466c Mon Sep 17 00:00:00 2001
From: Andrew Cooper <andrew.cooper3@citrix.com>
Date: Fri, 13 Dec 2024 14:34:00 +0000
Subject: [PATCH 19/38] x86/ucode: Perform extra SHA2 checks on AMD Fam17h/19h
 microcode
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Content-Type: text/plain; charset = "utf-8"
Content-Transfert-Encoding: 8bit

Collisions have been found in the microcode signing algorithm used by AMD
Fam17h/19h CPUs, and now anyone can sign their own.

For more details, see:
  https://bughunters.google.com/blog/5424842357473280/zen-and-the-art-of-microcode-hacking
  https://www.amd.com/en/resources/product-security/bulletin/amd-sb-7033.html

As a stopgap mitigation, check the digest of patches against a table of blobs
with known provenance.  These are all Fam17h and Fam19h blobs included in
linux-firwmare at the time of writing, specifically:

  https://git.kernel.org/firmware/linux-firmware/c/48bb90cceb882cab8e9ab692bc5779d3bf3a13b8

This checks can be opted out of by booting with ucode=no-digest-check, but
doing so is not recommended.

Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Acked-by: Roger Pau Monn√© <roger.pau@citrix.com>
(cherry picked from commit 630e8875ab368b97cc7231aaf3809e3d7d5687e1)

Xen: CI fix from XSN-2

 * Add cf_check annotation to cmp_patch_id() used by bsearch().

Fixes: 630e8875ab36 ("x86/ucode: Perform extra SHA2 checks on AMD Fam17h/19h microcode")
Signed-off-by: Andrew Cooper <andrew.cooper3@citrix.com>
Reviewed-by: Stefano Stabellini <sstabellini@kernel.org>
(cherry picked from commit 15fe2eb5f1bac8a212c0ba3d6dfe60d1fdf851cf)

Backported-by: Thierry Escande <thierry.escande@vates.tech>
Backport notes:
- Filename changes (not yet moved to xen/arch/x86/cpu/microcode)
- extern bool opt_digest_check; declared in microcode_amd.c instead of
  non-existing header file microcode/private.h
- cpu version check for disabled digest_check() warning message done in
  microcode_init_amd()
---
 docs/misc/xen-command-line.pandoc |   8 +-
 xen/arch/x86/amd-patch-digests.c  | 226 ++++++++++++++++++++++++++++++
 xen/arch/x86/microcode.c          |   4 +
 xen/arch/x86/microcode_amd.c      |  71 +++++++++-
 4 files changed, 306 insertions(+), 3 deletions(-)
 create mode 100644 xen/arch/x86/amd-patch-digests.c

diff --git a/docs/misc/xen-command-line.pandoc b/docs/misc/xen-command-line.pandoc
index 28df476..07e83ec 100644
--- a/docs/misc/xen-command-line.pandoc
+++ b/docs/misc/xen-command-line.pandoc
@@ -2337,7 +2337,7 @@ performance.
    Alternatively, selecting `tsx=1` will re-enable TSX at the users own risk.
 
 ### ucode (x86)
-> `= List of [ <integer> | scan=<bool>, nmi=<bool> ]`
+> `= List of [ <integer> | scan=<bool>, nmi=<bool>, digest-check=<bool> ]`
 
 Specify how and where to find CPU microcode update blob.
 
@@ -2362,6 +2362,12 @@ microcode in the cpio name space must be:
 stop_machine context. In NMI handler, even NMIs are blocked, which is
 considered safer. The default value is `true`.
 
+The `digest-check=` option is active by default and controls whether to
+perform additional authenticity checks.  Collisions in the signature algorithm
+used by AMD Fam17h/19h processors have been found.  Xen contains a table of
+digests of microcode patches with known-good provenance, and will block
+loading of patches that do not match.
+
 ### unrestricted_guest (Intel)
 > `= <boolean>`
 
diff --git a/xen/arch/x86/amd-patch-digests.c b/xen/arch/x86/amd-patch-digests.c
new file mode 100644
index 0000000..d327612
--- /dev/null
+++ b/xen/arch/x86/amd-patch-digests.c
@@ -0,0 +1,226 @@
+/* Generated from linux-firmware. */
+{
+    .patch_id = 0x0800126f,
+    .digest = {
+        0x2b, 0x5a, 0xf2, 0x9c, 0xdd, 0xd2, 0x7f, 0xec,
+        0xec, 0x96, 0x09, 0x57, 0xb0, 0x96, 0x29, 0x8b,
+        0x2e, 0x26, 0x91, 0xf0, 0x49, 0x33, 0x42, 0x18,
+        0xdd, 0x4b, 0x65, 0x5a, 0xd4, 0x15, 0x3d, 0x33,
+    },
+},
+{
+    .patch_id = 0x0800820d,
+    .digest = {
+        0x68, 0x98, 0x83, 0xcd, 0x22, 0x0d, 0xdd, 0x59,
+        0x73, 0x2c, 0x5b, 0x37, 0x1f, 0x84, 0x0e, 0x67,
+        0x96, 0x43, 0x83, 0x0c, 0x46, 0x44, 0xab, 0x7c,
+        0x7b, 0x65, 0x9e, 0x57, 0xb5, 0x90, 0x4b, 0x0e,
+    },
+},
+{
+    .patch_id = 0x0830107c,
+    .digest = {
+        0x21, 0x64, 0xde, 0xfb, 0x9f, 0x68, 0x96, 0x47,
+        0x70, 0x5c, 0xe2, 0x8f, 0x18, 0x52, 0x6a, 0xac,
+        0xa4, 0xd2, 0x2e, 0xe0, 0xde, 0x68, 0x66, 0xc3,
+        0xeb, 0x1e, 0xd3, 0x3f, 0xbc, 0x51, 0x1d, 0x38,
+    },
+},
+{
+    .patch_id = 0x0860010d,
+    .digest = {
+        0x86, 0xb6, 0x15, 0x83, 0xbc, 0x3b, 0x9c, 0xe0,
+        0xb3, 0xef, 0x1d, 0x99, 0x84, 0x35, 0x15, 0xf7,
+        0x7c, 0x2a, 0xc6, 0x42, 0xdb, 0x73, 0x07, 0x5c,
+        0x7d, 0xc3, 0x02, 0xb5, 0x43, 0x06, 0x5e, 0xf8,
+    },
+},
+{
+    .patch_id = 0x08608108,
+    .digest = {
+        0x14, 0xfe, 0x57, 0x86, 0x49, 0xc8, 0x68, 0xe2,
+        0x11, 0xa3, 0xcb, 0x6e, 0xff, 0x6e, 0xd5, 0x38,
+        0xfe, 0x89, 0x1a, 0xe0, 0x67, 0xbf, 0xc4, 0xcc,
+        0x1b, 0x9f, 0x84, 0x77, 0x2b, 0x9f, 0xaa, 0xbd,
+    },
+},
+{
+    .patch_id = 0x08701034,
+    .digest = {
+        0xc3, 0x14, 0x09, 0xa8, 0x9c, 0x3f, 0x8d, 0x83,
+        0x9b, 0x4c, 0xa5, 0xb7, 0x64, 0x8b, 0x91, 0x5d,
+        0x85, 0x6a, 0x39, 0x26, 0x1e, 0x14, 0x41, 0xa8,
+        0x75, 0xea, 0xa6, 0xf9, 0xc9, 0xd1, 0xea, 0x2b,
+    },
+},
+{
+    .patch_id = 0x08a0000a,
+    .digest = {
+        0x73, 0x31, 0x26, 0x22, 0xd4, 0xf9, 0xee, 0x3c,
+        0x07, 0x06, 0xe7, 0xb9, 0xad, 0xd8, 0x72, 0x44,
+        0x33, 0x31, 0xaa, 0x7d, 0xc3, 0x67, 0x0e, 0xdb,
+        0x47, 0xb5, 0xaa, 0xbc, 0xf5, 0xbb, 0xd9, 0x20,
+    },
+},
+{
+    .patch_id = 0x0a00107a,
+    .digest = {
+        0x5f, 0x92, 0xca, 0xff, 0xc3, 0x59, 0x22, 0x5f,
+        0x02, 0xa0, 0x91, 0x3b, 0x4a, 0x45, 0x10, 0xfd,
+        0x19, 0xe1, 0x8a, 0x6d, 0x9a, 0x92, 0xc1, 0x3f,
+        0x75, 0x78, 0xac, 0x78, 0x03, 0x1d, 0xdb, 0x18,
+    },
+},
+{
+    .patch_id = 0x0a0011d5,
+    .digest = {
+        0xed, 0x69, 0x89, 0xf4, 0xeb, 0x64, 0xc2, 0x13,
+        0xe0, 0x51, 0x1f, 0x03, 0x26, 0x52, 0x7d, 0xb7,
+        0x93, 0x5d, 0x65, 0xca, 0xb8, 0x12, 0x1d, 0x62,
+        0x0d, 0x5b, 0x65, 0x34, 0x69, 0xb2, 0x62, 0x21,
+    },
+},
+{
+    .patch_id = 0x0a001238,
+    .digest = {
+        0x72, 0xf7, 0x4b, 0x0c, 0x7d, 0x58, 0x65, 0xcc,
+        0x00, 0xcc, 0x57, 0x16, 0x68, 0x16, 0xf8, 0x2a,
+        0x1b, 0xb3, 0x8b, 0xe1, 0xb6, 0x83, 0x8c, 0x7e,
+        0xc0, 0xcd, 0x33, 0xf2, 0x8d, 0xf9, 0xef, 0x59,
+    },
+},
+{
+    .patch_id = 0x0a00820c,
+    .digest = {
+        0xa8, 0x0c, 0x81, 0xc0, 0xa6, 0x00, 0xe7, 0xf3,
+        0x5f, 0x65, 0xd3, 0xb9, 0x6f, 0xea, 0x93, 0x63,
+        0xf1, 0x8c, 0x88, 0x45, 0xd7, 0x82, 0x80, 0xd1,
+        0xe1, 0x3b, 0x8d, 0xb2, 0xf8, 0x22, 0x03, 0xe2,
+    },
+},
+{
+    .patch_id = 0x0a101148,
+    .digest = {
+        0x20, 0xd5, 0x6f, 0x40, 0x4a, 0xf6, 0x48, 0x90,
+        0xc2, 0x93, 0x9a, 0xc2, 0xfd, 0xac, 0xef, 0x4f,
+        0xfa, 0xc0, 0x3d, 0x92, 0x3c, 0x6d, 0x01, 0x08,
+        0xf1, 0x5e, 0xb0, 0xde, 0xb4, 0x98, 0xae, 0xc4,
+    },
+},
+{
+    .patch_id = 0x0a101248,
+    .digest = {
+        0xed, 0x3b, 0x95, 0xa6, 0x68, 0xa7, 0x77, 0x3e,
+        0xfc, 0x17, 0x26, 0xe2, 0x7b, 0xd5, 0x56, 0x22,
+        0x2c, 0x1d, 0xef, 0xeb, 0x56, 0xdd, 0xba, 0x6e,
+        0x1b, 0x7d, 0x64, 0x9d, 0x4b, 0x53, 0x13, 0x75,
+    },
+},
+{
+    .patch_id = 0x0a108108,
+    .digest = {
+        0xed, 0xc2, 0xec, 0xa1, 0x15, 0xc6, 0x65, 0xe9,
+        0xd0, 0xef, 0x39, 0xaa, 0x7f, 0x55, 0x06, 0xc6,
+        0xf5, 0xd4, 0x3f, 0x7b, 0x14, 0xd5, 0x60, 0x2c,
+        0x28, 0x1e, 0x9c, 0x59, 0x69, 0x99, 0x4d, 0x16,
+    },
+},
+{
+    .patch_id = 0x0a20102d,
+    .digest = {
+        0xf9, 0x6e, 0xf2, 0x32, 0xd3, 0x0f, 0x5f, 0x11,
+        0x59, 0xa1, 0xfe, 0xcc, 0xcd, 0x9b, 0x42, 0x89,
+        0x8b, 0x89, 0x2f, 0xb5, 0xbb, 0x82, 0xef, 0x23,
+        0x8c, 0xe9, 0x19, 0x3e, 0xcc, 0x3f, 0x7b, 0xb4,
+    },
+},
+{
+    .patch_id = 0x0a201210,
+    .digest = {
+        0xe8, 0x6d, 0x51, 0x6a, 0x8e, 0x72, 0xf3, 0xfe,
+        0x6e, 0x16, 0xbc, 0x62, 0x59, 0x40, 0x17, 0xe9,
+        0x6d, 0x3d, 0x0e, 0x6b, 0xa7, 0xac, 0xe3, 0x68,
+        0xf7, 0x55, 0xf0, 0x13, 0xbb, 0x22, 0xf6, 0x41,
+    },
+},
+{
+    .patch_id = 0x0a404107,
+    .digest = {
+        0xbb, 0x04, 0x4e, 0x47, 0xdd, 0x5e, 0x26, 0x45,
+        0x1a, 0xc9, 0x56, 0x24, 0xa4, 0x4c, 0x82, 0xb0,
+        0x8b, 0x0d, 0x9f, 0xf9, 0x3a, 0xdf, 0xc6, 0x81,
+        0x13, 0xbc, 0xc5, 0x25, 0xe4, 0xc5, 0xc3, 0x99,
+    },
+},
+{
+    .patch_id = 0x0a500011,
+    .digest = {
+        0x23, 0x3d, 0x70, 0x7d, 0x03, 0xc3, 0xc4, 0xf4,
+        0x2b, 0x82, 0xc6, 0x05, 0xda, 0x80, 0x0a, 0xf1,
+        0xd7, 0x5b, 0x65, 0x3a, 0x7d, 0xab, 0xdf, 0xa2,
+        0x11, 0x5e, 0x96, 0x7e, 0x71, 0xe9, 0xfc, 0x74,
+    },
+},
+{
+    .patch_id = 0x0a601209,
+    .digest = {
+        0x66, 0x48, 0xd4, 0x09, 0x05, 0xcb, 0x29, 0x32,
+        0x66, 0xb7, 0x9a, 0x76, 0xcd, 0x11, 0xf3, 0x30,
+        0x15, 0x86, 0xcc, 0x5d, 0x97, 0x0f, 0xc0, 0x46,
+        0xe8, 0x73, 0xe2, 0xd6, 0xdb, 0xd2, 0x77, 0x1d,
+    },
+},
+{
+    .patch_id = 0x0a704107,
+    .digest = {
+        0xf3, 0xc6, 0x58, 0x26, 0xee, 0xac, 0x3f, 0xd6,
+        0xce, 0xa1, 0x72, 0x47, 0x3b, 0xba, 0x2b, 0x93,
+        0x2a, 0xad, 0x8e, 0x6b, 0xea, 0x9b, 0xb7, 0xc2,
+        0x64, 0x39, 0x71, 0x8c, 0xce, 0xe7, 0x41, 0x39,
+    },
+},
+{
+    .patch_id = 0x0a705206,
+    .digest = {
+        0x8d, 0xc0, 0x76, 0xbd, 0x58, 0x9f, 0x8f, 0xa4,
+        0x12, 0x9d, 0x21, 0xfb, 0x48, 0x21, 0xbc, 0xe7,
+        0x67, 0x6f, 0x04, 0x18, 0xae, 0x20, 0x87, 0x4b,
+        0x03, 0x35, 0xe9, 0xbe, 0xfb, 0x06, 0xdf, 0xfc,
+    },
+},
+{
+    .patch_id = 0x0a708007,
+    .digest = {
+        0x6b, 0x76, 0xcc, 0x78, 0xc5, 0x8a, 0xa3, 0xe3,
+        0x32, 0x2d, 0x79, 0xe4, 0xc3, 0x80, 0xdb, 0xb2,
+        0x07, 0xaa, 0x3a, 0xe0, 0x57, 0x13, 0x72, 0x80,
+        0xdf, 0x92, 0x73, 0x84, 0x87, 0x3c, 0x73, 0x93,
+    },
+},
+{
+    .patch_id = 0x0a70c005,
+    .digest = {
+        0x88, 0x5d, 0xfb, 0x79, 0x64, 0xd8, 0x46, 0x3b,
+        0x4a, 0x83, 0x8e, 0x77, 0x7e, 0xcf, 0xb3, 0x0f,
+        0x1f, 0x1f, 0xf1, 0x97, 0xeb, 0xfe, 0x56, 0x55,
+        0xee, 0x49, 0xac, 0xe1, 0x8b, 0x13, 0xc5, 0x13,
+    },
+},
+{
+    .patch_id = 0x0aa00116,
+    .digest = {
+        0xe8, 0x4c, 0x2c, 0x88, 0xa1, 0xac, 0x24, 0x63,
+        0x65, 0xe5, 0xaa, 0x2d, 0x16, 0xa9, 0xc3, 0xf5,
+        0xfe, 0x1d, 0x5e, 0x65, 0xc7, 0xaa, 0x92, 0x4d,
+        0x91, 0xee, 0x76, 0xbb, 0x4c, 0x66, 0x78, 0xc9,
+    },
+},
+{
+    .patch_id = 0x0aa00215,
+    .digest = {
+        0x55, 0xd3, 0x28, 0xcb, 0x87, 0xa9, 0x32, 0xe9,
+        0x4e, 0x85, 0x4b, 0x7c, 0x6b, 0xd5, 0x7c, 0xd4,
+        0x1b, 0x51, 0x71, 0x3a, 0x0e, 0x0b, 0xdc, 0x9b,
+        0x68, 0x2f, 0x46, 0xee, 0xfe, 0xc6, 0x6d, 0xef,
+    },
+},
diff --git a/xen/arch/x86/microcode.c b/xen/arch/x86/microcode.c
index e495133..b4bde43 100644
--- a/xen/arch/x86/microcode.c
+++ b/xen/arch/x86/microcode.c
@@ -101,6 +101,8 @@ static bool_t __initdata ucode_scan;
 /* By default, ucode loading is done in NMI handler */
 static bool ucode_in_nmi = true;
 
+bool opt_digest_check = true;
+
 /* Protected by microcode_mutex */
 static struct microcode_patch *microcode_cache;
 
@@ -127,6 +129,8 @@ static int __init parse_ucode(const char *s)
 
         if ( (val = parse_boolean("nmi", s, ss)) >= 0 )
             ucode_in_nmi = val;
+        else if ( (val = parse_boolean("digest-check", s, ss)) >= 0 )
+            opt_digest_check = val;
         else if ( !ucode_mod_forced ) /* Not forced by EFI */
         {
             if ( (val = parse_boolean("scan", s, ss)) >= 0 )
diff --git a/xen/arch/x86/microcode_amd.c b/xen/arch/x86/microcode_amd.c
index 69b6fd8..ffb5c62 100644
--- a/xen/arch/x86/microcode_amd.c
+++ b/xen/arch/x86/microcode_amd.c
@@ -18,6 +18,7 @@
 #include <xen/kernel.h>
 #include <xen/init.h>
 #include <xen/sched.h>
+#include <xen/sha2.h>
 #include <xen/smp.h>
 #include <xen/spinlock.h>
 
@@ -92,6 +93,61 @@ static struct {
     uint16_t id;
 } equiv __read_mostly;
 
+static const struct patch_digest {
+    uint32_t patch_id;
+    uint8_t digest[SHA2_256_DIGEST_SIZE];
+} patch_digests[] = {
+#include "amd-patch-digests.c"
+};
+
+static int cmp_patch_id(const void *key, const void *elem)
+{
+    const struct patch_digest *pd = elem;
+    uint32_t patch_id = *(uint32_t *)key;
+
+    if ( patch_id == pd->patch_id )
+        return 0;
+    else if ( patch_id < pd->patch_id )
+        return -1;
+    return 1;
+}
+
+extern bool opt_digest_check;
+
+static bool check_digest(const struct container_microcode *mc)
+{
+    const struct microcode_patch *patch = mc->patch;
+    const struct patch_digest *pd;
+    uint8_t digest[SHA2_256_DIGEST_SIZE];
+
+    /* Only Fam17h/19h are known to need extra checks.  Skip other families. */
+    if ( boot_cpu_data.x86 < 0x17 || boot_cpu_data.x86 > 0x19 ||
+         !opt_digest_check )
+        return true;
+
+    pd = bsearch(&patch->patch_id, patch_digests, ARRAY_SIZE(patch_digests),
+                 sizeof(struct patch_digest), cmp_patch_id);
+    if ( !pd )
+    {
+        printk(XENLOG_WARNING "No digest found for patch_id %08x\n",
+               patch->patch_id);
+        return false;
+    }
+
+    sha2_256_digest(digest, patch, mc->len);
+
+    if ( memcmp(digest, pd->digest, sizeof(digest)) )
+    {
+        printk(XENLOG_WARNING "Patch %08x SHA256 mismatch:\n"
+               "  expected %" STR(SHA2_256_DIGEST_SIZE) "phN\n"
+               "       got %" STR(SHA2_256_DIGEST_SIZE) "phN\n",
+               patch->patch_id, pd->digest, digest);
+        return false;
+    }
+
+    return true;
+}
+
 /* See comment in start_update() for cases when this routine fails */
 static int collect_cpu_info(struct cpu_signature *csig)
 {
@@ -416,7 +472,8 @@ static struct microcode_patch *cpu_request_microcode(const void *buf, size_t siz
              * one with higher revision.
              */
             if ( (microcode_fits(mc->patch) != MIS_UCODE) &&
-                 (!saved || (compare_header(mc->patch, saved) == NEW_UCODE)) )
+                 (!saved || (compare_header(mc->patch, saved) == NEW_UCODE)) &&
+                 check_digest(mc) )
             {
                 saved = mc->patch;
                 saved_size = mc->len;
@@ -470,7 +527,17 @@ static const struct microcode_ops microcode_amd_ops = {
 
 int __init microcode_init_amd(void)
 {
-    if ( boot_cpu_data.x86_vendor == X86_VENDOR_AMD )
+    if ( boot_cpu_data.x86_vendor == X86_VENDOR_AMD ) {
         microcode_ops = &microcode_amd_ops;
+
+        if ( !opt_digest_check &&
+             boot_cpu_data.x86 >= 0x17 && boot_cpu_data.x86 <= 0x19 )
+        {
+            printk(XENLOG_WARNING
+                   "Microcode patch additional digest checks disabled");
+            add_taint(TAINT_CPU_OUT_OF_SPEC);
+        }
+    }
+
     return 0;
 }
-- 
2.47.2

