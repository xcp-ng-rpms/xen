From 8f62b5ce8a4dbbd45e14d9c4fd3e8e4d62c7f882 Mon Sep 17 00:00:00 2001
From: David Morel <david.morel@vates.tech>
Date: Wed, 27 Mar 2024 09:48:56 +0100
Subject: hypercall_xlat_continuation: Replace BUG_ON with domain_crash

Backport notes:
- using XSA-454 v1, based on 4.16 patches
- applied without changes, with offsets

From: Bjoern Doebel <doebel@amazon.de>
Subject: hypercall_xlat_continuation: Replace BUG_ON with domain_crash

Instead of crashing the host in case of unexpected hypercall parameters,
resort to only crashing the calling domain.

This is part of XSA-454 / CVE-2023-46842.

Fixes: b8a7efe8528a ("Enable compatibility mode operation for HYPERVISOR_memory_op")
Signed-off-by: Bjoern Doebel <doebel@amazon.de>
Signed-off-by: Jan Beulich <jbeulich@suse.com>
Reviewed-by: Roger Pau Monn√© <roger.pau@citrix.com>
Backported-by: David Morel <david.morel@vates.tech>

---
 xen/arch/x86/hypercall.c | 36 ++++++++++++++++++++++++++++--------
 1 file changed, 28 insertions(+), 8 deletions(-)

diff --git a/xen/arch/x86/hypercall.c b/xen/arch/x86/hypercall.c
index c2877c6..42240d7 100644
--- a/xen/arch/x86/hypercall.c
+++ b/xen/arch/x86/hypercall.c
@@ -194,8 +194,13 @@ int hypercall_xlat_continuation(unsigned int *id, unsigned int nr,
                 cval = va_arg(args, unsigned int);
                 if ( cval == nval )
                     mask &= ~1U;
-                else
-                    BUG_ON(nval == (unsigned int)nval);
+                else if ( nval == (unsigned int)nval )
+                {
+                    printk(XENLOG_G_ERR
+                           "multicall (op %lu) bogus continuation arg%u (%#lx)\n",
+                           mcs->call.op, i, nval);
+                    domain_crash(current->domain);
+                }
             }
             else if ( id && *id == i )
             {
@@ -207,8 +212,13 @@ int hypercall_xlat_continuation(unsigned int *id, unsigned int nr,
                 mcs->call.args[i] = cval;
                 ++rc;
             }
-            else
-                BUG_ON(mcs->call.args[i] != (unsigned int)mcs->call.args[i]);
+            else if ( mcs->call.args[i] != (unsigned int)mcs->call.args[i] )
+            {
+                printk(XENLOG_G_ERR
+                       "multicall (op %lu) bad continuation arg%u (%#lx)\n",
+                       mcs->call.op, i, mcs->call.args[i]);
+                domain_crash(current->domain);
+            }
         }
     }
     else
@@ -234,8 +244,13 @@ int hypercall_xlat_continuation(unsigned int *id, unsigned int nr,
                 cval = va_arg(args, unsigned int);
                 if ( cval == nval )
                     mask &= ~1U;
-                else
-                    BUG_ON(nval == (unsigned int)nval);
+                else if ( nval == (unsigned int)nval )
+                {
+                    printk(XENLOG_G_ERR
+                           "hypercall (op %u) bogus continuation arg%u (%#lx)\n",
+                           regs->eax, i, nval);
+                    domain_crash(current->domain);
+                }
             }
             else if ( id && *id == i )
             {
@@ -247,8 +262,13 @@ int hypercall_xlat_continuation(unsigned int *id, unsigned int nr,
                 *reg = cval;
                 ++rc;
             }
-            else
-                BUG_ON(*reg != (unsigned int)*reg);
+            else if ( *reg != (unsigned int)*reg )
+            {
+                printk(XENLOG_G_ERR
+                       "hypercall (op %u) bad continuation arg%u (%#lx)\n",
+                       regs->eax, i, *reg);
+                domain_crash(current->domain);
+            }
         }
     }
 
-- 
2.43.2

