Hypercall to obtain aggregated domain runstate information, and bindings.

The "legacy" struct xen_domctl_runstate_info cannot change.  The Ocaml
types/functions (runstate, domain_get_runstate_info, etc) cannot change.

The newer xen_domctl_runstate_info_ext can be extended if a new Ocaml
Runstateinfo.Vn module is created, and become set in stone when the next build
of Xen is produced.

diff --git a/tools/flask/policy/modules/dom0.te b/tools/flask/policy/modules/dom0.te
index f1dcff48e227..522d0278db93 100644
--- a/tools/flask/policy/modules/dom0.te
+++ b/tools/flask/policy/modules/dom0.te
@@ -41,6 +41,7 @@ allow dom0_t dom0_t:domain {
 allow dom0_t dom0_t:domain2 {
 	set_cpu_policy gettsc settsc setscheduler set_vnumainfo
 	get_vnumainfo psr_cmt_op psr_alloc get_cpu_policy
+	get_runstate_info
 };
 allow dom0_t dom0_t:resource { add remove };
 
diff --git a/tools/flask/policy/modules/xen.if b/tools/flask/policy/modules/xen.if
index 11c1562aa5da..e3e9be2e70be 100644
--- a/tools/flask/policy/modules/xen.if
+++ b/tools/flask/policy/modules/xen.if
@@ -54,6 +54,7 @@ define(`create_domain_common', `
 	allow $1 $2:domain2 { set_cpu_policy settsc setscheduler setclaim
 			set_vnumainfo get_vnumainfo cacheflush
 			psr_cmt_op psr_alloc soft_reset
+			get_runstate_info
 			resource_map get_cpu_policy };
 	allow $1 $2:security check_context;
 	allow $1 $2:shadow enable;
diff --git a/tools/include/xenctrl.h b/tools/include/xenctrl.h
index 9047b163e8f8..97e5e92ba503 100644
--- a/tools/include/xenctrl.h
+++ b/tools/include/xenctrl.h
@@ -445,6 +445,7 @@ typedef struct xc_core_header {
  */
 
 typedef xen_domctl_getdomaininfo_t xc_domaininfo_t;
+typedef xen_domctl_runstate_info_t xc_runstate_info_t;
 
 static inline unsigned int dominfo_shutdown_reason(const xc_domaininfo_t *info)
 {
@@ -1371,6 +1372,15 @@ int xc_domain_get_pod_target(xc_interface *xch,
                              uint64_t *pod_cache_pages,
                              uint64_t *pod_entries);
 
+#define XENCTRL_HAS_GET_RUNSTATE_INFO 1
+int xc_get_runstate_info(xc_interface *xch,
+			 uint32_t domid,
+			 xc_runstate_info_t *info);
+#define XENCTRL_HAS_GET_RUNSTATE_INFO_EXT 1
+int xc_get_runstate_info_ext(xc_interface *xch,
+                             uint32_t domid,
+                             struct xen_domctl *domctl);
+
 int xc_domain_ioport_permission(xc_interface *xch,
                                 uint32_t domid,
                                 uint32_t first_port,
diff --git a/tools/libs/ctrl/xc_domain.c b/tools/libs/ctrl/xc_domain.c
index 19e218f73987..951ab2a53079 100644
--- a/tools/libs/ctrl/xc_domain.c
+++ b/tools/libs/ctrl/xc_domain.c
@@ -1339,6 +1339,37 @@ int xc_vcpu_getinfo(xc_interface *xch,
     return rc;
 }
 
+int xc_get_runstate_info(xc_interface *xch, uint32_t domid, xc_runstate_info_t *info)
+{
+    /* The main caller is statically linked.  Careful with the ABI. */
+    BUILD_BUG_ON(sizeof(*info) != 64);
+
+    struct xen_domctl domctl = {
+        .cmd = XEN_DOMCTL_get_runstate_info,
+        .domain = domid,
+    };
+    int ret = do_domctl(xch, &domctl);
+
+    if ( ret < 0 )
+        return ret;
+
+    /* Note, this takes the runstate_info subset of the runstate_info_ext field. */
+    memcpy(info, &domctl.u.domain_runstate, sizeof(*info));
+
+    return ret;
+}
+
+/* Passes back the whole domctl structure, so it can be extended more easily. */
+int xc_get_runstate_info_ext(xc_interface *xch, uint32_t domid, struct xen_domctl *domctl)
+{
+    *domctl = (struct xen_domctl){
+        .cmd = XEN_DOMCTL_get_runstate_info,
+        .domain = domid,
+    };
+
+    return do_domctl(xch, domctl);
+}
+
 int xc_domain_ioport_permission(xc_interface *xch,
                                 uint32_t domid,
                                 uint32_t first_port,
diff --git a/tools/ocaml/libs/xc/xenctrl.ml b/tools/ocaml/libs/xc/xenctrl.ml
index 3578c48fa99a..d976a67d7de1 100644
--- a/tools/ocaml/libs/xc/xenctrl.ml
+++ b/tools/ocaml/libs/xc/xenctrl.ml
@@ -205,6 +205,44 @@ external domain_create_stub: handle -> domid -> domctl_create_config -> domid
 let domain_create handle ?(domid=0) config =
 	domain_create_stub handle domid config
 
+module Runstateinfo = struct
+  module V1 = struct
+    (* Retain old names for backwards compatibility *)
+    type runstateinfo = {
+      state: int32;
+      missed_changes: int32;
+      state_entry_time: int64;
+      time0: int64;
+      time1: int64;
+      time2: int64;
+      time3: int64;
+      time4: int64;
+      time5: int64;
+    }
+    external domain_get_runstate_info : handle -> int -> runstateinfo = "stub_xc_get_runstate_info"
+  end
+
+  module V2 = struct
+    type t = {
+      state: int32;
+      missed_changes: int32;
+      state_entry_time: int64;
+      time0: int64;
+      time1: int64;
+      time2: int64;
+      time3: int64;
+      time4: int64;
+      time5: int64;
+      runnable: int64;
+      running: int64;
+      nonaffine: int64;
+    }
+    external domain_get : handle -> int -> t = "stub_xc_get_runstate_info2"
+  end
+end
+
+include Runstateinfo.V1
+
 external domain_sethandle: handle -> domid -> string -> unit
        = "stub_xc_domain_sethandle"
 
diff --git a/tools/ocaml/libs/xc/xenctrl.mli b/tools/ocaml/libs/xc/xenctrl.mli
index 22131db920d0..c725313088c4 100644
--- a/tools/ocaml/libs/xc/xenctrl.mli
+++ b/tools/ocaml/libs/xc/xenctrl.mli
@@ -165,6 +165,44 @@ val close_handle: unit -> unit
 
 val domain_create: handle -> ?domid:int -> domctl_create_config -> domid
 
+module Runstateinfo : sig
+  module V1 : sig
+    (* Retain old names for backwards compatibility *)
+    type runstateinfo = {
+      state: int32;
+      missed_changes: int32;
+      state_entry_time: int64;
+      time0: int64;
+      time1: int64;
+      time2: int64;
+      time3: int64;
+      time4: int64;
+      time5: int64;
+    }
+    external domain_get_runstate_info : handle -> int -> runstateinfo = "stub_xc_get_runstate_info"
+  end
+
+  module V2 : sig
+    type t = {
+      state: int32;
+      missed_changes: int32;
+      state_entry_time: int64;
+      time0: int64;
+      time1: int64;
+      time2: int64;
+      time3: int64;
+      time4: int64;
+      time5: int64;
+      runnable: int64;
+      running: int64;
+      nonaffine: int64;
+    }
+    external domain_get : handle -> int -> t = "stub_xc_get_runstate_info2"
+  end
+end
+
+include module type of Runstateinfo.V1
+
 external domain_sethandle : handle -> domid -> string -> unit = "stub_xc_domain_sethandle"
 external domain_max_vcpus : handle -> domid -> int -> unit
   = "stub_xc_domain_max_vcpus"
diff --git a/tools/ocaml/libs/xc/xenctrl_stubs.c b/tools/ocaml/libs/xc/xenctrl_stubs.c
index 93ff008dc5d8..4b96727ab08e 100644
--- a/tools/ocaml/libs/xc/xenctrl_stubs.c
+++ b/tools/ocaml/libs/xc/xenctrl_stubs.c
@@ -500,6 +500,68 @@ CAMLprim value stub_xc_vcpu_getinfo(value xch, value domid, value vcpu)
 	CAMLreturn(result);
 }
 
+CAMLprim value stub_xc_get_runstate_info(value xch, value domid)
+{
+        CAMLparam2(xch, domid);
+        CAMLlocal1(result);
+        xc_runstate_info_t info;
+        int retval;
+
+        retval = xc_get_runstate_info(_H(xch), _D(domid), &info);
+        if (retval < 0)
+                failwith_xc(_H(xch));
+
+        /* Store
+           0 : state (int32)
+           1 : missed_changes (int32)
+           2 : state_entry_time (int64)
+           3-8 : times (int64s)
+        */
+        result = caml_alloc_tuple(9);
+        Store_field(result, 0, caml_copy_int32(info.state));
+        Store_field(result, 1, caml_copy_int32(info.missed_changes));
+        Store_field(result, 2, caml_copy_int64(info.state_entry_time));
+        Store_field(result, 3, caml_copy_int64(info.time[0]));
+        Store_field(result, 4, caml_copy_int64(info.time[1]));
+        Store_field(result, 5, caml_copy_int64(info.time[2]));
+        Store_field(result, 6, caml_copy_int64(info.time[3]));
+        Store_field(result, 7, caml_copy_int64(info.time[4]));
+        Store_field(result, 8, caml_copy_int64(info.time[5]));
+
+        CAMLreturn(result);
+}
+
+CAMLprim value stub_xc_get_runstate_info2(value xch, value domid)
+{
+	CAMLparam2(xch, domid);
+	CAMLlocal1(result);
+	struct xen_domctl d;
+	int retval;
+
+	caml_enter_blocking_section();
+	retval = xc_get_runstate_info_ext(_H(xch), _D(domid), &d);
+	caml_leave_blocking_section();
+
+	if (retval < 0)
+		failwith_xc(_H(xch));
+
+	result = caml_alloc_tuple(12);
+	Store_field(result, 0, caml_copy_int32(d.u.domain_runstate.state));
+	Store_field(result, 1, caml_copy_int32(d.u.domain_runstate.missed_changes));
+	Store_field(result, 2, caml_copy_int64(d.u.domain_runstate.state_entry_time));
+	Store_field(result, 3, caml_copy_int64(d.u.domain_runstate.time[0]));
+	Store_field(result, 4, caml_copy_int64(d.u.domain_runstate.time[1]));
+	Store_field(result, 5, caml_copy_int64(d.u.domain_runstate.time[2]));
+	Store_field(result, 6, caml_copy_int64(d.u.domain_runstate.time[3]));
+	Store_field(result, 7, caml_copy_int64(d.u.domain_runstate.time[4]));
+	Store_field(result, 8, caml_copy_int64(d.u.domain_runstate.time[5]));
+	Store_field(result, 9, caml_copy_int64(d.u.domain_runstate.runnable));
+	Store_field(result, 10, caml_copy_int64(d.u.domain_runstate.running));
+	Store_field(result, 11, caml_copy_int64(d.u.domain_runstate.nonaffine));
+
+	CAMLreturn(result);
+}
+
 CAMLprim value stub_xc_vcpu_context_get(value xch, value domid,
                                         value cpu)
 {
diff --git a/xen/common/domain.c b/xen/common/domain.c
index 70a2284a1299..428ebef6490a 100644
--- a/xen/common/domain.c
+++ b/xen/common/domain.c
@@ -602,6 +602,7 @@ struct domain *domain_create(domid_t domid,
     spin_lock_init_prof(d, domain_lock);
     spin_lock_init_prof(d, page_alloc_lock);
     spin_lock_init(&d->hypercall_deadlock_mutex);
+    spin_lock_init(&d->runstate_lock);
     INIT_PAGE_LIST_HEAD(&d->page_list);
     INIT_PAGE_LIST_HEAD(&d->extra_page_list);
     INIT_PAGE_LIST_HEAD(&d->xenpage_list);
diff --git a/xen/common/domctl.c b/xen/common/domctl.c
index 6cf78d4975bd..bda8548348ec 100644
--- a/xen/common/domctl.c
+++ b/xen/common/domctl.c
@@ -860,6 +860,11 @@ long do_domctl(XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)
                 __HYPERVISOR_domctl, "h", u_domctl);
         break;
 
+    case XEN_DOMCTL_get_runstate_info:
+        domain_runstate_get(d, &op->u.domain_runstate);
+        copyback = 1;
+        break;
+
     default:
         ret = arch_do_domctl(op, d, u_domctl);
         break;
diff --git a/xen/common/sched/core.c b/xen/common/sched/core.c
index 320a6166a2be..63ba4916645c 100644
--- a/xen/common/sched/core.c
+++ b/xen/common/sched/core.c
@@ -276,6 +276,7 @@ static inline bool is_running_nonaffine(const struct vcpu *v,
 static inline void vcpu_runstate_change(
     struct vcpu *v, int new_state, s_time_t new_entry_time)
 {
+    struct domain *d = v->domain;
     s_time_t delta;
     struct sched_unit *unit = v->sched_unit;
 
@@ -305,6 +306,65 @@ static inline void vcpu_runstate_change(
     }
 
     v->runstate.state = new_state;
+
+    /* Update domain runstate */
+    if ( spin_trylock(&d->runstate_lock) )
+    {
+        static const char mask_to_state[] = {
+            /* 000: Nothing in any runstate.  Should never happen. */
+            -1,
+            /* 001: All running */
+            DOMAIN_RUNSTATE_full_run,
+            /* 010: All runnable */
+            DOMAIN_RUNSTATE_full_contention,
+            /* 011: Some running, some runnable */
+            DOMAIN_RUNSTATE_concurrency_hazard,
+            /* 100: All blocked / offline */
+            DOMAIN_RUNSTATE_blocked,
+            /* 101: Some running, some blocked / offline */
+            DOMAIN_RUNSTATE_partial_run,
+            /* 110: Some blocked / offline, some runnable */
+            DOMAIN_RUNSTATE_partial_contention,
+            /* 111: Some in every state.  Mixed running + runnable is most important. */
+            DOMAIN_RUNSTATE_concurrency_hazard,
+        };
+
+        unsigned mask=0;
+        struct vcpu *ov;
+
+        BUG_ON(d->runstate.state > DOMAIN_RUNSTATE_partial_contention);
+
+        d->runstate.time[d->runstate.state] +=
+            (new_entry_time - d->runstate.state_entry_time);
+        d->runstate.state_entry_time = new_entry_time;
+
+        /* Determine new runstate.  First, see what states we have */
+        for_each_vcpu(d, ov)
+        {
+            /* Don't count vcpus that have beent taken offline by the guest */
+            if ( !(ov->runstate.state == RUNSTATE_offline &&
+                   test_bit(_VPF_down, &ov->pause_flags)) )
+               mask |= (1 << ov->runstate.state);
+        }
+
+        if ( mask == 0 )
+        {
+            printk("%s: d%d has no online vcpus!\n",
+                   __func__, d->domain_id);
+            mask = 1 << RUNSTATE_offline;
+        }
+
+        /* Offline & blocked are the same */
+        mask |= ((1 << RUNSTATE_offline) & mask) >> 1;
+
+        d->runstate.state = mask_to_state[mask&0x7];
+
+        spin_unlock(&d->runstate_lock);
+    }
+    else
+    {
+        atomic_inc(&d->runstate_missed_changes);
+    }
 }
 
 void sched_guest_idle(void (*idle) (void), unsigned int cpu)
@@ -372,6 +432,37 @@ struct vcpu_runstate_extra vcpu_runstate_get(
     return ret;
 }
 
+void domain_runstate_get(struct domain *d, domain_runstate_info_t *info)
+{
+    struct vcpu *v;
+
+    /* Have to disable interrupts because the other user of the lock runs
+     * in interrupt context. */
+    spin_lock_irq(&d->runstate_lock);
+
+    memcpy(info, &d->runstate, sizeof(*info));
+    info->time[d->runstate.state] += NOW() - info->state_entry_time;
+    info->missed_changes = atomic_read(&d->runstate_missed_changes);
+
+    spin_unlock_irq(&d->runstate_lock);
+
+    info->runnable = 0;
+    info->running = 0;
+    info->nonaffine = 0;
+    for_each_vcpu ( d, v )
+    {
+        /* Get a snapshot of the accumulated vcpu times (until this moment) */
+        struct vcpu_runstate_info vcpu_runstate;
+        struct vcpu_runstate_extra ret = vcpu_runstate_get(v, &vcpu_runstate);
+
+        /* Aggregate the vCPU time sum of the domain in the runnable state */
+        info->runnable += vcpu_runstate.time[RUNSTATE_runnable] / d->max_vcpus;
+        /* Aggregate the vCPU time sum of the domain in the running state */
+        info->running += vcpu_runstate.time[RUNSTATE_running] / d->max_vcpus;
+        info->nonaffine += ret.nonaffine_time / d->max_vcpus;
+    }
+}
+
 uint64_t get_cpu_idle_time(unsigned int cpu)
 {
     struct vcpu_runstate_info state = { 0 };
diff --git a/xen/include/public/domctl.h b/xen/include/public/domctl.h
index 7ba3a565209e..eb1d3f7f8134 100644
--- a/xen/include/public/domctl.h
+++ b/xen/include/public/domctl.h
@@ -1189,6 +1189,50 @@ struct xen_domctl_vmtrace_op {
 typedef struct xen_domctl_vmtrace_op xen_domctl_vmtrace_op_t;
 DEFINE_XEN_GUEST_HANDLE(xen_domctl_vmtrace_op_t);
 
+/*
+ * Return information about the state and running time of a domain.
+ * The "domain runstate" is based on the runstates of all the vcpus of the
+ * domain (see below).
+ * @extra_arg == pointer to domain_runstate_info structure.
+ */
+struct xen_domctl_runstate_info {
+#define DOMAIN_RUNSTATE_full_run           0 /* All vcpus are running */
+#define DOMAIN_RUNSTATE_full_contention    1 /* All vcpus are runnable (i.e., waiting for cpu) */
+#define DOMAIN_RUNSTATE_concurrency_hazard 2 /* Some vcpus are running, some are runnable */
+#define DOMAIN_RUNSTATE_blocked            3 /* All vcpus are blocked / offline */
+#define DOMAIN_RUNSTATE_partial_run        4 /* Some vpcus are running, some are blocked */
+#define DOMAIN_RUNSTATE_partial_contention 5 /* Some vcpus are runnable, some are blocked */
+    uint32_t      state;
+    uint32_t missed_changes;
+    /* Number of times we missed an update due to contention */
+    /* When was current state entered (system time, ns)? */
+    uint64_aligned_t state_entry_time;
+    /*
+     * Time spent in each RUNSTATE_* (ns). The sum of these times is
+     * NOT guaranteed not to drift from system time.
+     */
+    uint64_aligned_t time[6];
+};
+typedef struct xen_domctl_runstate_info xen_domctl_runstate_info_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_runstate_info_t);
+
+/* A form of xen_domctl_runstate_info which can be extended in some circumstances. */
+struct xen_domctl_runstate_info_ext {
+    uint32_t state;
+    uint32_t missed_changes;
+    uint64_aligned_t state_entry_time;
+    uint64_aligned_t time[6]; /* up to here must be identical to xen_domctl_runstate_info */
+
+    /* Average runnable time of vCPUs in the domain */
+    uint64_aligned_t runnable;
+    /* Normalised vCPU time running */
+    uint64_aligned_t running;
+    /* Normalised vCPU time running non-affine */
+    uint64_aligned_t nonaffine;
+};
+typedef struct xen_domctl_runstate_info_ext xen_domctl_runstate_info_ext_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_runstate_info_ext_t);
+
 struct xen_domctl {
     uint32_t cmd;
 #define XEN_DOMCTL_createdomain                   1
@@ -1276,6 +1320,7 @@ struct xen_domctl {
 #define XEN_DOMCTL_vmtrace_op                    84
 #define XEN_DOMCTL_get_paging_mempool_size       85
 #define XEN_DOMCTL_set_paging_mempool_size       86
+#define XEN_DOMCTL_get_runstate_info             98
 #define XEN_DOMCTL_gdbsx_guestmemio            1000
 #define XEN_DOMCTL_gdbsx_pausevcpu             1001
 #define XEN_DOMCTL_gdbsx_unpausevcpu           1002
@@ -1326,6 +1371,7 @@ struct xen_domctl {
         struct xen_domctl_set_access_required access_required;
         struct xen_domctl_audit_p2m         audit_p2m;
         struct xen_domctl_set_virq_handler  set_virq_handler;
+        struct xen_domctl_runstate_info_ext domain_runstate;
         struct xen_domctl_gdbsx_memio       gdbsx_guest_memio;
         struct xen_domctl_set_broken_page_p2m set_broken_page_p2m;
         struct xen_domctl_cacheflush        cacheflush;
diff --git a/xen/include/xen/sched.h b/xen/include/xen/sched.h
index df3b77171541..f4a4a7a21f32 100644
--- a/xen/include/xen/sched.h
+++ b/xen/include/xen/sched.h
@@ -376,6 +376,8 @@ struct evtchn_port_ops;
 
 #define MAX_NR_IOREQ_SERVERS 8
 
+typedef struct xen_domctl_runstate_info_ext domain_runstate_info_t;
+
 struct domain
 {
     domid_t          domain_id;
@@ -617,6 +619,11 @@ struct domain
 
     /* Holding CDF_* constant. Internal flags for domain creation. */
     unsigned int cdf;
+
+    /* Domain runstates */
+    spinlock_t runstate_lock;
+    atomic_t runstate_missed_changes;
+    domain_runstate_info_t runstate;
 } __aligned(PAGE_SIZE);
 
 static inline struct page_list_head *page_to_list(
@@ -1048,6 +1055,7 @@ int vcpu_affinity_domctl(struct domain *d, uint32_t cmd,
 
 struct vcpu_runstate_extra vcpu_runstate_get(
     const struct vcpu *v, struct vcpu_runstate_info *runstate);
+void domain_runstate_get(struct domain *d, domain_runstate_info_t *info);
 
 uint64_t get_cpu_idle_time(unsigned int cpu);
 void sched_guest_idle(void (*idle) (void), unsigned int cpu);
diff --git a/xen/xsm/flask/hooks.c b/xen/xsm/flask/hooks.c
index 42857c212223..2737c4f2cc4a 100644
--- a/xen/xsm/flask/hooks.c
+++ b/xen/xsm/flask/hooks.c
@@ -838,6 +838,9 @@ static int cf_check flask_domctl(struct domain *d, unsigned int cmd,
     case XEN_DOMCTL_set_paging_mempool_size:
         return current_has_perm(d, SECCLASS_DOMAIN, DOMAIN__SETPAGINGMEMPOOL);
 
+    case XEN_DOMCTL_get_runstate_info:
+        return current_has_perm(d, SECCLASS_DOMAIN2, DOMAIN2__GET_RUNSTATE_INFO);
+
     default:
         return avc_unknown_permission("domctl", cmd);
     }
diff --git a/xen/xsm/flask/policy/access_vectors b/xen/xsm/flask/policy/access_vectors
index 4e6710a63e1b..48bc5502b9e8 100644
--- a/xen/xsm/flask/policy/access_vectors
+++ b/xen/xsm/flask/policy/access_vectors
@@ -247,6 +247,8 @@ class domain2
     psr_alloc
 # XENMEM_resource_map
     resource_map
+# XEN_DOMCTL_get_runstate_info
+    get_runstate_info
 # XEN_DOMCTL_get_cpu_policy
     get_cpu_policy
 }
