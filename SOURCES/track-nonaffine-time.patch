From: Bernhard Kaindl <bernhard.kaindl@cloud.com>
Date: Tue, 22 Jul 2025 12:00:00 +0200
Subject: Track vcpu->nonaffine_time for each vCPU

- Add a new time counter, nonaffine_time to struct vcpu.
- Add a new inline function to check if a vCPU is/was nonaffine.
- Use it in the vcpu_runstate_change handler for vcpu->nonaffine_time

Note:
- We cannot change struct vcpu_runstate_info to add this counter:
  It is part of the guest runstate shared memory area which is
  in the guest ABI that is frozen and cannot be changed.

Update vcpu_runstate_get() to return a snapshot of the current
non-affine vCPU time at the time of call.

Signed-off-by: Bernhard Kaindl <bernhard.kaindl@cloud.com>

diff --git a/xen/common/sched/core.c b/xen/common/sched/core.c
index 4fdacc8f97f8..5f88b88ab4da 100644
--- a/xen/common/sched/core.c
+++ b/xen/common/sched/core.c
@@ -259,6 +259,20 @@ static inline void vcpu_urgent_count_update(struct vcpu *v)
     }
 }
 
+/*
+ * For accounting purposes, we need to know whether a vCPU is (or was just)
+ * running outside of the soft affinity mask of the scheduling unit. We check
+ * this in the vcpu_runstate_get() and the vcpu_runstate_change() functions.
+ *
+ * This is used to account for the time spent running non-affine.
+ */
+static inline bool is_running_nonaffine(const struct vcpu *v,
+                                        const struct sched_unit *unit)
+{
+    return v->runstate.state == RUNSTATE_running && has_soft_affinity(unit) &&
+           !cpumask_test_cpu(v->processor, unit->cpu_soft_affinity);
+}
+
 static inline void vcpu_runstate_change(
     struct vcpu *v, int new_state, s_time_t new_entry_time)
 {
@@ -283,6 +297,10 @@ static inline void vcpu_runstate_change(
     if ( delta > 0 )
     {
         v->runstate.time[v->runstate.state] += delta;
+
+        if ( is_running_nonaffine(v, unit) )
+            v->runstate_extra.nonaffine_time += delta;
+
         v->runstate.state_entry_time = new_entry_time;
     }
 
@@ -303,12 +321,25 @@ void sched_guest_idle(void (*idle) (void), unsigned int cpu)
     atomic_dec(&per_cpu(sched_urgent_count, cpu));
 }
 
-void vcpu_runstate_get(const struct vcpu *v,
-                       struct vcpu_runstate_info *runstate)
+/**
+ * vcpu_runstate_get(): Return vCPU time spent in different runstates
+ *
+ * @param v:        vCPU to get runstate times (since vCPU start)
+ * @param runstate: Return time spent in each runstate.
+ *                  This structure is part of the runstate memory areas
+ *                  shared with the domains which is part of the ABI
+ *                  with domains that is frozen and cannot be changed.
+ *                  To return additional values, use e.g. the return
+ *                  value(no need to change all callers) of this function.
+ * @returns         struct with non-affine running time since vcpu creation
+ */
+struct vcpu_runstate_extra vcpu_runstate_get(
+    const struct vcpu *v, struct vcpu_runstate_info *runstate)
 {
     spinlock_t *lock;
     s_time_t delta;
     struct sched_unit *unit;
+    struct vcpu_runstate_extra ret;
 
     rcu_read_lock(&sched_res_rculock);
 
@@ -322,14 +353,23 @@ void vcpu_runstate_get(const struct vcpu *v,
                            : v->sched_unit;
     lock = likely(v == current) ? NULL : unit_schedule_lock_irq(unit);
     memcpy(runstate, &v->runstate, sizeof(*runstate));
+    ret = v->runstate_extra;
+
     delta = NOW() - runstate->state_entry_time;
     if ( delta > 0 )
+    {
         runstate->time[runstate->state] += delta;
 
+        if ( is_running_nonaffine(v, unit) )
+            ret.nonaffine_time += delta;
+    }
+
     if ( unlikely(lock != NULL) )
         unit_schedule_unlock_irq(lock, unit);
 
     rcu_read_unlock(&sched_res_rculock);
+
+    return ret;
 }
 
 uint64_t get_cpu_idle_time(unsigned int cpu)
diff --git a/xen/include/xen/sched.h b/xen/include/xen/sched.h
index 38acbc6e8dc9..9be7bb93778e 100644
--- a/xen/include/xen/sched.h
+++ b/xen/include/xen/sched.h
@@ -192,7 +192,19 @@ struct vcpu
 
     struct sched_unit *sched_unit;
 
+    /*
+     * The struct vcpu_runstate_info contains the vCPU time spent
+     * in each runstate and the entry time of the current runstate.
+     *
+     * Note: This field is used for the guest runstate shared memory area.
+     * Therefore, it is part of the frozen guest API and cannot be changed.
+     */
     struct vcpu_runstate_info runstate;
+
+    struct vcpu_runstate_extra {
+        uint64_t nonaffine_time; /* Time running outside soft_affinity mask */
+    } runstate_extra;
+
 #ifndef CONFIG_COMPAT
 # define runstate_guest(v) ((v)->runstate_guest)
     XEN_GUEST_HANDLE(vcpu_runstate_info_t) runstate_guest; /* guest address */
@@ -1078,8 +1090,9 @@ int vcpu_set_hard_affinity(struct vcpu *v, const cpumask_t *affinity);
 int vcpu_affinity_domctl(struct domain *d, uint32_t cmd,
                          struct xen_domctl_vcpuaffinity *vcpuaff);
 
-void vcpu_runstate_get(const struct vcpu *v,
-                       struct vcpu_runstate_info *runstate);
+struct vcpu_runstate_extra vcpu_runstate_get(
+    const struct vcpu *v, struct vcpu_runstate_info *runstate);
+
 uint64_t get_cpu_idle_time(unsigned int cpu);
 void sched_guest_idle(void (*idle) (void), unsigned int cpu);
 void scheduler_enable(void);
